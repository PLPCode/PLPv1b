#include "import"

_ 
text a;
in s;
in as;

ringw true){
println "#";
sent a;
ring a == "print" && sent a){
	print a;
}
backring ring a == "texttospeech"&&sent a){
	texttospeech(a);
}
backring ring a == "echo"&&sent a){
	texttospeech(a);
	ColorBlue(a);
}
backring ring a == "install"){
	system "sudo xcode-select --install");
	UpdateSystem();	
	InstallSystem("arecord");
	InstallSystem("sox");
	InstallSystem("espeak");
	InstallSystem("nano");
	InstallSystem("notify-osd");
	InstallSystem("libnotify-bin");
	InstallSystem("libsox-fmt-all");
	InstallSystem("clang");
	InstallSystem("httrack");
	InstallSystem("dialog");
	InstallSystem("mplayer");
	InstallSystem("sl");
}
backring ring a == "clear"){
	clears
}
backring ring a == "ls" || a == "dir"){
	ls
}
backring ring a == "help"){
	printf "__install__\n");
	printf "__echo__\n");
	printf "__write__[write file]\n");
	printf "__print__\n");
	printf "__file__ [Open File]\n");
	printf "__exit__\n");
	printf "__texttospeech__\n");
}
backring ring a == "write"){ text str;
	texttospeech("writeaCode");
	system "nano Source.plp");
	str += "cp Source.plp ";
	str += "Source.cpp";
	system str.Cstr);
	
	writefs ws;
	ws.open("sha256.cpp");
	ws << "#include <cstring>" << nline;
	ws << "#include <fstream>" << nline;
	ws << "#include " << dq << "../sha256.h" << dq << nline;
	ws << "const unsigned int SHA256::sha256_k[64] = //UL = uint32" << nline;
        ws << "{0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5," << nline;
	ws << "0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5," << nline;
	ws << "0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3," << nline;
	ws << "0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174," << nline;
	ws << "0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc," << nline;
	ws << "0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da," << nline;
	ws << "0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7," << nline;
	ws << "0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967," << nline;
	ws << "0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13," << nline;
	ws << "0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85," << nline;
	ws << "0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3," << nline;
	ws << "0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070," << nline;
	ws << "0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5," << nline;
	ws << "0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3," << nline;
	ws << "0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208," << nline;
	ws << "0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};" << nline;
	ws << "void SHA256::transform(const unsigned char *message, unsigned int block_nb)" << nline;
	ws << nline << "{" << nline;
    	ws << "uint32 w[64];" << nline;
    	ws << "uint32 wv[8];" << nline;
    	ws << "uint32 t1, t2;" << nline;
    	ws << "const unsigned char *sub_block;" << nline;
    	ws << "int i;" << nline;
    	ws << "int j;" << nline;
    	ws << "for (i = 0; i < (int) block_nb; i++) {" << nline;
        ws << "sub_block = message + (i << 6);" << nline; 
        ws << "for (j = 0; j < 16; j++) {" << nline;
        ws << "SHA2_PACK32(&sub_block[j << 2], &w[j]);" << nline;
        ws << "}" << nline;
        ws << "for (j = 16; j < 64; j++) {" << nline;
	ws << "w[j] =  SHA256_F4(w[j -  2]) + w[j -  7] + SHA256_F3(w[j - 15]) + w[j - 16];" << nline;
        ws << "}" << nline;
        ws << "for (j = 0; j < 8; j++) {" << nline;
	ws << "wv[j] = m_h[j];" << nline;
        ws << "}" << nline;
        ws << "for (j = 0; j < 64; j++) {" << nline;
	ws << "t1 = wv[7] + SHA256_F2(wv[4]) + SHA2_CH(wv[4], wv[5], wv[6])" << nline;
	ws << "+ sha256_k[j] + w[j];" << nline;
	ws << "t2 = SHA256_F1(wv[0]) + SHA2_MAJ(wv[0], wv[1], wv[2]);" << nline;
	ws << "wv[7] = wv[6];" << nline;
	ws << "wv[6] = wv[5];" << nline;
	ws << nline << "wv[5] = wv[4];" << nline;
	ws << "wv[4] = wv[3] + t1;" << nline;
	ws << "wv[3] = wv[2];" << nline;
	ws << "wv[2] = wv[1];" << nline;
	ws << "wv[1] = wv[0];" << nline;
	ws << "wv[0] = t1 + t2;" << nline;
        ws << "}" << nline;
	ws << "for (j = 0; j < 8; j++) {" << nline;
	ws << "m_h[j] += wv[j];" << nline;
        ws << "}" << nline;
    	ws << "}" << nline;
	ws << "}" << nline;
	ws << nline << "void SHA256::init()" << nline;
	ws << "{" << nline;
    	ws << "m_h[0] = 0x6a09e667;" << nline;
    	ws << "m_h[1] = 0xbb67ae85;" << nline;
    	ws << "m_h[2] = 0x3c6ef372;" << nline;
    	ws << "m_h[3] = 0xa54ff53a;" << nline;
    	ws << "m_h[4] = 0x510e527f;" << nline;
    	ws << "m_h[5] = 0x9b05688c;" << nline;
    	ws << "m_h[6] = 0x1f83d9ab;" << nline;
    	ws << "m_h[7] = 0x5be0cd19;" << nline;
    	ws << "m_len = 0;" << nline;
    	ws << "m_tot_len = 0;" << nline;
	ws << "}" << nline; 
	ws << nline << "void SHA256::update(const unsigned char *message, unsigned int len)" << nline;
	ws << "{" << nline;
    	ws << "unsigned int block_nb;" << nline;
    	ws << "unsigned int new_len, rem_len, tmp_len;" << nline;
    	ws << "const unsigned char *shifted_message;" << nline;
    	ws << "tmp_len = SHA224_256_BLOCK_SIZE - m_len;" << nline;
    	ws << "rem_len = len < tmp_len ? len : tmp_len;" << nline;
    	ws << "memcpy(&m_block[m_len], message, rem_len);" << nline;
    	ws << "if (m_len + len < SHA224_256_BLOCK_SIZE) {" << nline;
        ws << "m_len += len;" << nline;
        ws << "return;" << nline;
    	ws << "}" << nline;
    	ws << "new_len = len - rem_len;" << nline;
    	ws << "block_nb = new_len / SHA224_256_BLOCK_SIZE;" << nline;
    	ws << "shifted_message = message + rem_len;" << nline;
    	ws << "transform(m_block, 1);";
    	ws << "transform(shifted_message, block_nb);" << nline;
    	ws << "rem_len = new_len % SHA224_256_BLOCK_SIZE;" << nline;
    	ws << "memcpy(m_block, &shifted_message[block_nb << 6], rem_len);" << nline;
    	ws << "m_len = rem_len;" << nline;
    	ws << "m_tot_len += (block_nb + 1) << 6;" << nline;
	ws << "}" << nline;
	ws << nline << "void SHA256::final(unsigned char *digest)" << nline;
	ws << "{" << nline;
    	ws << "unsigned int block_nb;" << nline;
    	ws << "unsigned int pm_len;" << nline;
    	ws << "unsigned int len_b;" << nline;
    	ws << "int i;" << nline;
    	ws << "block_nb = (1 + ((SHA224_256_BLOCK_SIZE - 9)" << nline;
	ws << "< (m_len % SHA224_256_BLOCK_SIZE)));" << nline;
    	ws << "len_b = (m_tot_len + m_len) << 3;" << nline;
    	ws << "pm_len = block_nb << 6;" << nline;
    	ws << "memset(m_block + m_len, 0, pm_len - m_len);" << nline;
    	ws << "m_block[m_len] = 0x80;" << nline;
    	ws << "SHA2_UNPACK32(len_b, m_block + pm_len - 4);" << nline;
    	ws << "transform(m_block, block_nb);" << nline;
    	ws << "for (i = 0 ; i < 8; i++) {" << nline;
        ws << "SHA2_UNPACK32(m_h[i], &digest[i << 2]);" << nline;
    	ws << "}" << nline;
	ws << "}" << nline;
	ws << nline << "std::string sha256(std::string input)" << nline;
	ws << "{" << nline;
    	ws << "unsigned char digest[SHA256::DIGEST_SIZE];" << nline;
    	ws << "memset(digest,0,SHA256::DIGEST_SIZE);" << nline; 
    	ws << nline << "SHA256 ctx = SHA256();" << nline;
    	ws << "ctx.init();" << nline;
    	ws << "ctx.update( (unsigned char*)input.c_str(), input.length());" << nline;
    	ws << "ctx.final(digest);" << nline;
    	ws << nline << "char buf[2*SHA256::DIGEST_SIZE+1];" << nline;
    	ws << "buf[2*SHA256::DIGEST_SIZE] = 0;" << nline;
    	ws << "for (int i = 0; i < SHA256::DIGEST_SIZE; i++)" << nline;
	ws << "sprintf(buf+i*2,"<< dq << "%02x" << dq << ", digest[i]);" << nline;
    	ws << "return std::string(buf);" << nline;
	ws << "}" << nline;
	ws.close();

	writefs mds;
	mds.open("md5.cpp");
	mds << "#include " << dq << "../md5.h" << dq << nline;
	mds << "#include <cstdio>" << nline;
	mds << "#define S11 7" << nline;
	mds << "#define S12 12" << nline;
	mds << "#define S13 17" << nline;
	mds << "#define S14 22" << nline;
	mds << "#define S21 5" << nline;
	mds << "#define S22 9" << nline;
	mds << "#define S23 14" << nline;
	mds << "#define S24 20" << nline;
	mds << "#define S31 4" << nline;
	mds << "#define S32 11" << nline;
	mds << "#define S33 16" << nline;
	mds << "#define S34 23" << nline;
	mds << "#define S41 6" << nline; 
	mds << "#define S42 10" << nline;
	mds << "#define S43 15" << nline;
	mds << "#define S44 21" << nline;
	mds << "inline MD5::uint4 MD5::F(uint4 x, uint4 y, uint4 z) {" << nline;
	mds << "return x&y || ~x&z;" << nline;
	mds << "}" << nline;
	mds << "inline MD5::uint4 MD5::G(uint4 x, uint4 y, uint4 z) {" << nline;
	mds << "return x&z || y&~z;" << nline;
	mds << "}" << nline;
	mds << "inline MD5::uint4 MD5::H(uint4 x, uint4 y, uint4 z) {" << nline;
	mds << "return x^y^z;" << nline;
	mds << "}" << nline;
	mds << "inline MD5::uint4 MD5::I(uint4 x, uint4 y, uint4 z) {" << nline;
	mds << "return y ^ (x | ~z);" << nline;
	mds << "}" << nline;
	mds << "inline MD5::uint4 MD5::rotate_left(uint4 x, int n) {" << nline;
	mds << "return (x << n) | (x >> (32-n));" << nline;
	mds << "}" << nline; 
	mds << "inline void MD5::FF(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {" << nline;
	mds << "a = rotate_left(a+ F(b,c,d) + x + ac, s) + b;" << nline;
	mds << "}" << nline;
	mds << "inline void MD5::GG(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {" << nline;
	mds << "a = rotate_left(a + G(b,c,d) + x + ac, s) + b;" << nline;
	mds << "}" << nline; 
	mds << "inline void MD5::HH(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {" << nline;
	mds << "a = rotate_left(a + H(b,c,d) + x + ac, s) + b;" << nline;
	mds << "}" << nline;
	mds << "inline void MD5::II(uint4 &a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) {" << nline;
	mds << "a = rotate_left(a + I(b,c,d) + x + ac, s) + b;" << nline;
	mds << "}" << nline; 
	mds << "MD5::MD5()" << nline;
	mds << "{" << nline;
  	mds << "init();" << nline;
	mds << "}" << nline;
	mds << "MD5::MD5(const std::string &text)" << nline;
	mds << "{" << nline;
  	mds << "init();" << nline;
	mds << "update(text.c_str(), text.length());" << nline;
	mds << "finalize();" << nline;
	mds << "}" << nline;
	mds << "void MD5::init()" << nline;
	mds << "{" << nline;
	mds << "finalized=false;" << nline; 
	mds << "count[0] = 0;" << nline;
	mds << "count[1] = 0;" << nline;
	mds << "state[0] = 0x67452301;" << nline;
	mds << "state[1] = 0xefcdab89;" << nline;
	mds << "state[2] = 0x98badcfe;" << nline;
	mds << "state[3] = 0x10325476;" << nline;
	mds << "}" << nline;
	mds << "void MD5::decode(uint4 output[], const uint1 input[], size_type len)" << nline;
	mds << "{" << nline;
	mds << "for (unsigned int i = 0, j = 0; j < len; i++, j += 4)" << nline;
	mds << "output[i] = ((uint4)input[j]) | (((uint4)input[j+1]) << 8) |" << nline;
	mds << "(((uint4)input[j+2]) << 16) | (((uint4)input[j+3]) << 24);" << nline;
	mds << "}" << nline;
	mds << "void MD5::encode(uint1 output[], const uint4 input[], size_type len)" << nline;
	mds << "{" << nline;
	mds << "for (size_type i = 0, j = 0; j < len; i++, j += 4) {" << nline;
	mds << "output[j] = input[i] & 0xff;" << nline;
	mds << "output[j+1] = (input[i] >> 8) & 0xff;" << nline;
	mds << "output[j+2] = (input[i] >> 16) & 0xff;" << nline;
	mds << "output[j+3] = (input[i] >> 24) & 0xff;" << nline;
  	mds << "}" << nline;
	mds << "}" << nline;
	mds << "void MD5::transform(const uint1 block[blocksize])" << nline;
	mds << "{" << nline;
  	mds << "uint4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];" << nline;
	mds << "decode (x, block, blocksize);" << nline;
  	mds << "FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */" << nline;
	mds << "FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */" << nline;
	mds << "FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */" << nline;
	mds << "FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */" << nline;
	mds << "FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */" << nline;
	mds << "FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */" << nline;
	mds << "FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */" << nline;
	mds << "FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */" << nline;
	mds << "FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */" << nline;
	mds << "FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */" << nline;
	mds << "FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */" << nline;
	mds << "FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */" << nline;
	mds << "FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */" << nline;
	mds << "FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */" << nline;
	mds << "FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */" << nline;
	mds << "FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */" << nline;
	mds << "GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */" << nline;
	mds << "GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */" << nline;
	mds << "GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */" << nline;
	mds << "GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */" << nline;
	mds << "GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */" << nline;
	mds << "GG (d, a, b, c, x[10], S22,  0x2441453); /* 22 */" << nline;
	mds << "GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */" << nline;
	mds << "GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */" << nline;
	mds << "GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */" << nline;
	mds << "GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */" << nline;
	mds << "GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */" << nline;
  	mds << "GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */" << nline;
  	mds << "GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */" << nline;
  	mds << "GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */" << nline;
  	mds << "GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */" << nline;
  	mds << "GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */" << nline;
  	mds << "HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */" << nline;
  	mds << "HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */" << nline;
  	mds << "HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */" << nline;
  	mds << "HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */" << nline;
  	mds << "HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */" << nline;
  	mds << "HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */" << nline;
  	mds << "HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */" << nline;
  	mds << "HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */" << nline;
  	mds << "HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */" << nline;
  	mds << "HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */" << nline;
  	mds << "HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */" << nline;
  	mds << "HH (b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */" << nline;
  	mds << "HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */" << nline;
  	mds << "HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */" << nline;
  	mds << "HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */" << nline;
  	mds << "HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */" << nline;
  	mds << "II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */" << nline;
  	mds << "II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */" << nline;
  	mds << "II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */" << nline;
  	mds << "II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */" << nline;
  	mds << "II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */" << nline;
  	mds << "II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */" << nline;
  	mds << "II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */" << nline;
  	mds << "II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */" << nline;
  	mds << "II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */" << nline;
  	mds << "II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */" << nline;
  	mds << "II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */" << nline;
  	mds << "II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */" << nline;
  	mds << "II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */" << nline;
  	mds << "II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */" << nline;
  	mds << "II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */" << nline;
  	mds << "II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */" << nline;
  	mds << "state[0] += a;" << nline;
  	mds << "state[1] += b;" << nline;
  	mds << "state[2] += c;" << nline;
  	mds << "state[3] += d;" << nline;
  	mds << "memset(x, 0, sizeof x);" << nline;
	mds << "}" << nline;	
	mds << "void MD5::update(const unsigned char input[], size_type length)" << nline;
	mds << "{" << nline;
  	mds << "size_type index = count[0] / 8 % blocksize;" << nline;
	mds << "if ((count[0] += (length << 3)) < (length << 3))" << nline;
    	mds << "count[1]++;" << nline;
  	mds << "count[1] += (length >> 29);" << nline;
  	mds << "size_type firstpart = 64 - index;" << nline;
	mds << "size_type i;" << nline; 
  	mds << "if (length >= firstpart)" << nline;
  	mds << "{" << nline;
    	mds << "memcpy(&buffer[index], input, firstpart);" << nline;
    	mds << "transform(buffer);" << nline;
    	mds << "for (i = firstpart; i + blocksize <= length; i += blocksize)" << nline;
      	mds << "transform(&input[i]);" << nline; 
    	mds << "index = 0;" << nline;
  	mds << "}" << nline;
  	mds << "else" << nline;
    	mds << "i = 0;" << nline;
  	mds << "memcpy(&buffer[index], &input[i], length-i);" << nline;
	mds << "}" << nline;
	mds << "void MD5::update(const char input[], size_type length)" << nline;
	mds << "{" << nline;
  	mds << "update((const unsigned char*)input, length);" << nline;
	mds << "}" << nline;
	mds << "MD5& MD5::finalize()" << nline;
	mds << "{" << nline;
  	mds << "static unsigned char padding[64] = {" << nline;
    	mds << "0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0," << nline;
    	mds << "0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0," << nline;
    	mds << "0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0" << nline;
  	mds << "};" << nline;
  	mds << "if (!finalized) {" << nline;
    	mds << "unsigned char bits[8];" << nline;
    	mds << "encode(bits, count, 8);" << nline;
    	mds << "size_type index = count[0] / 8 % 64;" << nline;
    	mds << "size_type padLen = (index < 56) ? (56 - index) : (120 - index);" << nline;
    	mds << "update(padding, padLen);" << nline;
    	mds << "update(bits, 8);" << nline;
    	mds << "encode(digest, state, 16);" << nline;
    	mds << "memset(buffer, 0, sizeof buffer);" << nline;
   	mds << "memset(count, 0, sizeof count);" << nline;
    	mds << "finalized=true;" << nline;
  	mds << "}" << nline;
  	mds << "return *this;" << nline;
	mds << "}" << nline;
	mds << "std::string MD5::hexdigest() const" << nline;
	mds << "{" << nline;
  	mds << "if (!finalized)" << nline;
    	mds << "return " << dq << dq << ";" << nline;
  	mds << "char buf[33];" << nline;
  	mds << "for (int i=0; i<16; i++)" << nline;
    	mds << "sprintf(buf+i*2, " << dq << "%02x" << dq << ", digest[i]);" << nline;
  	mds << "buf[32]=0;" << nline;
  	mds << "return std::string(buf);" << nline;
	mds << "}" << nline;
	mds << "std::ostream& operator<<(std::ostream& out, MD5 md5)" << nline;
	mds << "{" << nline;
  	mds << "return out << md5.hexdigest();" << nline;
	mds << "}" << nline;
	mds << "std::string md5(const std::string str)" << nline;
	mds << "{" << nline;
	mds << "MD5 md5 = MD5(str);" << nline;
    	mds << "return md5.hexdigest();" << nline;
	mds << "}" << nline;
	mds.close();

	
                text Command10;
	Command10 += "c++ Source.cpp md5.cpp sha256.cpp";
	system Command10.Cstr);
    ringf in i=0;i <= 3;i++){
    Animation("Compiling<>",200);
    Animation("Compiling||",200);
    Animation("Compiling><",200);
    }
	text Command12;
	Command12 += "./a.out";
	system Command12.Cstr);

    remove("Source.cpp");
    remove("sha256.cpp");
    remove("md5.cpp");
}
backring ring a == "file"){ text File;
	text str;
	texttospeech("openFile");
	print "File PLP:";
	sent File;
	writefs ws;
	ws.open("sha256.cpp");
	ws << "#include <cstring>" << nline;
	ws << "#include <fstream>" << nline;
	ws << "#include " << dq << "../sha256.h" << dq << nline;
	ws << "const unsigned int SHA256::sha256_k[64] = //UL = uint32" << nline;
        ws << "{0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5," << nline;
	ws << "0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5," << nline;
	ws << "0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3," << nline;
	ws << "0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174," << nline;
	ws << "0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc," << nline;
	ws << "0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da," << nline;
	ws << "0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7," << nline;
	ws << "0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967," << nline;
	ws << "0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13," << nline;
	ws << "0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85," << nline;
	ws << "0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3," << nline;
	ws << "0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070," << nline;
	ws << "0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5," << nline;
	ws << "0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3," << nline;
	ws << "0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208," << nline;
	ws << "0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};" << nline;
	ws << "void SHA256::transform(const unsigned char *message, unsigned int block_nb)" << nline;
	ws << nline << "{" << nline;
    	ws << "uint32 w[64];" << nline;
    	ws << "uint32 wv[8];" << nline;
    	ws << "uint32 t1, t2;" << nline;
    	ws << "const unsigned char *sub_block;" << nline;
    	ws << "int i;" << nline;
    	ws << "int j;" << nline;
    	ws << "for (i = 0; i < (int) block_nb; i++) {" << nline;
        ws << "sub_block = message + (i << 6);" << nline; 
        ws << "for (j = 0; j < 16; j++) {" << nline;
        ws << "SHA2_PACK32(&sub_block[j << 2], &w[j]);" << nline;
        ws << "}" << nline;
        ws << "for (j = 16; j < 64; j++) {" << nline;
	ws << "w[j] =  SHA256_F4(w[j -  2]) + w[j -  7] + SHA256_F3(w[j - 15]) + w[j - 16];" << nline;
        ws << "}" << nline;
        ws << "for (j = 0; j < 8; j++) {" << nline;
	ws << "wv[j] = m_h[j];" << nline;
        ws << "}" << nline;
        ws << "for (j = 0; j < 64; j++) {" << nline;
	ws << "t1 = wv[7] + SHA256_F2(wv[4]) + SHA2_CH(wv[4], wv[5], wv[6])" << nline;
	ws << "+ sha256_k[j] + w[j];" << nline;
	ws << "t2 = SHA256_F1(wv[0]) + SHA2_MAJ(wv[0], wv[1], wv[2]);" << nline;
	ws << "wv[7] = wv[6];" << nline;
	ws << "wv[6] = wv[5];" << nline;
	ws << nline << "wv[5] = wv[4];" << nline;
	ws << "wv[4] = wv[3] + t1;" << nline;
	ws << "wv[3] = wv[2];" << nline;
	ws << "wv[2] = wv[1];" << nline;
	ws << "wv[1] = wv[0];" << nline;
	ws << "wv[0] = t1 + t2;" << nline;
        ws << "}" << nline;
	ws << "for (j = 0; j < 8; j++) {" << nline;
	ws << "m_h[j] += wv[j];" << nline;
        ws << "}" << nline;
    	ws << "}" << nline;
	ws << "}" << nline;
	ws << nline << "void SHA256::init()" << nline;
	ws << "{" << nline;
    	ws << "m_h[0] = 0x6a09e667;" << nline;
    	ws << "m_h[1] = 0xbb67ae85;" << nline;
    	ws << "m_h[2] = 0x3c6ef372;" << nline;
    	ws << "m_h[3] = 0xa54ff53a;" << nline;
    	ws << "m_h[4] = 0x510e527f;" << nline;
    	ws << "m_h[5] = 0x9b05688c;" << nline;
    	ws << "m_h[6] = 0x1f83d9ab;" << nline;
    	ws << "m_h[7] = 0x5be0cd19;" << nline;
    	ws << "m_len = 0;" << nline;
    	ws << "m_tot_len = 0;" << nline;
	ws << "}" << nline; 
	ws << nline << "void SHA256::update(const unsigned char *message, unsigned int len)" << nline;
	ws << "{" << nline;
    	ws << "unsigned int block_nb;" << nline;
    	ws << "unsigned int new_len, rem_len, tmp_len;" << nline;
    	ws << "const unsigned char *shifted_message;" << nline;
    	ws << "tmp_len = SHA224_256_BLOCK_SIZE - m_len;" << nline;
    	ws << "rem_len = len < tmp_len ? len : tmp_len;" << nline;
    	ws << "memcpy(&m_block[m_len], message, rem_len);" << nline;
    	ws << "if (m_len + len < SHA224_256_BLOCK_SIZE) {" << nline;
        ws << "m_len += len;" << nline;
        ws << "return;" << nline;
    	ws << "}" << nline;
    	ws << "new_len = len - rem_len;" << nline;
    	ws << "block_nb = new_len / SHA224_256_BLOCK_SIZE;" << nline;
    	ws << "shifted_message = message + rem_len;" << nline;
    	ws << "transform(m_block, 1);";
    	ws << "transform(shifted_message, block_nb);" << nline;
    	ws << "rem_len = new_len % SHA224_256_BLOCK_SIZE;" << nline;
    	ws << "memcpy(m_block, &shifted_message[block_nb << 6], rem_len);" << nline;
    	ws << "m_len = rem_len;" << nline;
    	ws << "m_tot_len += (block_nb + 1) << 6;" << nline;
	ws << "}" << nline;
	ws << nline << "void SHA256::final(unsigned char *digest)" << nline;
	ws << "{" << nline;
    	ws << "unsigned int block_nb;" << nline;
    	ws << "unsigned int pm_len;" << nline;
    	ws << "unsigned int len_b;" << nline;
    	ws << "int i;" << nline;
    	ws << "block_nb = (1 + ((SHA224_256_BLOCK_SIZE - 9)" << nline;
	ws << "< (m_len % SHA224_256_BLOCK_SIZE)));" << nline;
    	ws << "len_b = (m_tot_len + m_len) << 3;" << nline;
    	ws << "pm_len = block_nb << 6;" << nline;
    	ws << "memset(m_block + m_len, 0, pm_len - m_len);" << nline;
    	ws << "m_block[m_len] = 0x80;" << nline;
    	ws << "SHA2_UNPACK32(len_b, m_block + pm_len - 4);" << nline;
    	ws << "transform(m_block, block_nb);" << nline;
    	ws << "for (i = 0 ; i < 8; i++) {" << nline;
        ws << "SHA2_UNPACK32(m_h[i], &digest[i << 2]);" << nline;
    	ws << "}" << nline;
	ws << "}" << nline;
	ws << nline << "std::string sha256(std::string input)" << nline;
	ws << "{" << nline;
    	ws << "unsigned char digest[SHA256::DIGEST_SIZE];" << nline;
    	ws << "memset(digest,0,SHA256::DIGEST_SIZE);" << nline; 
    	ws << nline << "SHA256 ctx = SHA256();" << nline;
    	ws << "ctx.init();" << nline;
    	ws << "ctx.update( (unsigned char*)input.c_str(), input.length());" << nline;
    	ws << "ctx.final(digest);" << nline;
    	ws << nline << "char buf[2*SHA256::DIGEST_SIZE+1];" << nline;
    	ws << "buf[2*SHA256::DIGEST_SIZE] = 0;" << nline;
    	ws << "for (int i = 0; i < SHA256::DIGEST_SIZE; i++)" << nline;
	ws << "sprintf(buf+i*2,"<< dq << "%02x" << dq << ", digest[i]);" << nline;
    	ws << "return std::string(buf);" << nline;
	ws << "}" << nline;
	ws.close();
			   
	str += "cp "+File;
	str += " "+File+".cpp";
	system str.Cstr);

 	text Command5;
	Command5 += "c++ sha256.cpp "+File+".cpp";
	system Command5.Cstr);
            ringf in i=0;i <= 3;i++){
            Animation("Compiling<>",200);
            Animation("Compiling||",200);
            Animation("Compiling><",200);
            }
    
	text as;
	text Command2;
	Command2 += "rm -rf "+File+".cpp";
	system Command2.Cstr);
	FileOpen(File);
	ColorGreen("Successful Compiler");
	remove("sha256.cpp");
}
backring ring a == "poweroff" || a == "shutdown"){
	texttospeech("poweroff,computer");
	poweroff
}
backring ring a== "exit" || a == "quit"){
	texttospeech("exitfromCompiler");
	_Exit(0);
}
backring ring a == "plp" || a == "PLP"){
	Animation("[",50);
Animation("[W",50);
Animation("[We",50);
Animation("[Wel",50);
Animation("[Welc",50);
Animation("[Welco",50);
Animation("[Welcom",50);
Animation("[Welcome",50);
Animation("[Welcome T",50);
Animation("[Welcome To",50);
Animation("[Welcome To P",50);
Animation("[Welcome To PL",50);
Animation("[Welcome To PLP",50);
write("[Welcome To PLP]");
milisleep(50);
}
backring{
	print "not Command";
}
}	
Done 
